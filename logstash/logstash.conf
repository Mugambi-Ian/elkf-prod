input {
  file {
    path => "/var/lib/docker/containers/*/*.log"
    start_position => "beginning"
    sincedb_path => "/usr/share/logstash/data/sincedb"
    codec => "json"
    mode => "read"
  }
}

filter {
  # Parse the 'log' field which contains the actual application log
  if [log] {
    mutate {
      gsub => [
        "log", "\\r\\n", "",
        "log", "\\n", ""
      ]
    }

    json {
      source => "log"
      target => "app"
      skip_on_invalid_json => true
    }

    # Flatten app fields to root
    if [app] {
      ruby {
        code => "
          app = event.get('app')
          if app.is_a?(Hash)
            app.each { |k, v|
              event.set(k, v) unless ['@timestamp', '@version'].include?(k)
            }
          end
          event.remove('app')
        "
      }
    }

    # Remove the original 'log' field after parsing
    mutate {
      remove_field => ["log"]
    }
  }

  # Extract container ID from file path
  if [path] {
    grok {
      match => { "path" => "/var/lib/docker/containers/%{DATA:container_id}/%{GREEDYDATA}" }
    }
  }

  # Get container name using docker inspect
  if [container_id] {
    ruby {
      code => '
        require "open3"
        container_id = event.get("container_id")
        if container_id && container_id.length > 0
          stdout, stderr, status = Open3.capture3("docker", "inspect", "--format", "{{.Name}}", container_id)
          if status.success? && stdout && stdout.strip.length > 0
            container_name = stdout.strip.sub(/^\//, "")
            event.set("container_name", container_name)
          end
        end
      '
    }
  }

  # Set service.name from Pino log or container name
  if ![service][name] or [service][name] == "unknown" {
    if [container_name] {
      mutate {
        add_field => { "[service][name]" => "%{container_name}" }
      }
    }
  }

  # Parse Pino timestamp
  if [time] {
    date {
      match => [ "time", "ISO8601" ]
      target => "@timestamp"
      remove_field => ["time"]
    }
  }

  # Drop logs from ELK stack containers
  if [container_name] in ["logstash", "elasticsearch", "kibana", "cert_gen", "es_bootstrap"] {
    drop { }
  }

  # Security: Redact sensitive fields
  if [req][headers][authorization] {
    mutate {
      replace => { "[req][headers][authorization]" => "[REDACTED]" }
    }
  }

  if [req][body][password] {
    mutate {
      replace => { "[req][body][password]" => "[REDACTED]" }
    }
  }

  # Clean up metadata fields
  mutate {
    remove_field => ["stream", "path", "container_id", "host"]
  }
}

output {
  elasticsearch {
    hosts => ["https://elasticsearch:9200"]
    user => "elastic"
    password => "${ELASTIC_PASSWORD}"
    ssl => true
    ssl_certificate_verification => true
    cacert => "/usr/share/logstash/certs/ca/ca.crt"
    index => "app-logs-%{[service][name]}-%{+YYYY.MM.dd}"
    manage_template => false
  }

}